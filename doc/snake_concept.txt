/* стиль */
Надо переименовать class_t в Class.
Сложно и писать и читать эти class_t...

/* работа с графикой */
Сообрази как рисовать в буфер, а уже его передавать на вывод.
Так можно позиционировать и масштабировать картинку,
накладывать эффекты.

1. Использовать 1 или 2 буфера на базе
SDL_Surface.
Выводить тайлы на буфер.
"В конце" генерировать  текстуру и выводить ее на экран.
Не забыть эту текстуру потом йопнуть.

2. Наверное более адекватный по отношению с sdl2 вариант:
использовать SDL_SetRenderTarget с указанием буферной текстуры.
(да и существующий инструментарий не придется перепиливать)

Нужно кэшировать статичный текст. Сохранить в отдельные
текстуры, например (сделать функцию, которая не рисует текст,
а возвращает текстуру - важно! такие кэши нужно не забывать
удалять).

/* графические ресурсы */
Графика - один тайлсет на сеттинг.
Объекты хранят и передают
индексы тайлов.
Сеттинг:
пол
блок
бонус1
бонус2
бонус3
бонус4
змейка
???

/* программа */
для "собственно игры" и менюшки можно отдельные сущности описать: со
своими стадией визуализации, обработки ввода... вообще сделать объектами
с со своими обработчиками...

/* snake-1 */

Свойства:
typedef struct _snake_t {
x, y   // текущая позиция
px, py // прошлая позиция
d, m   // направление, движение
v, vmax, delay // скорость, задержка
size   // текущий размер
body[snake_size_max] // тело змейки
vup_delay, vup_delay_max // ускорение змейки
} snake_t;

typedef struct _t_body {
  x, y,
  px, py,
  m,
  tile_id
} snakebody_t

Начальное состояние:
(start_x, start_y)

hero->d=d_right
hero->m=0
hero->size = 3

hero->x = start_x
hero->y = start_y
for(int i = 0; i < hero->size; i++) {
  hero->body[i].x = start_x + (i+1);
  hero->body[i].y = start_y;
}

Управление
k_right: if(d_left != hero-> d) { hero->d = d_right; hero->m = 1; }
k_up: if(D_DOWN != hero->d) { hero->d = d_up; hero->m = 1; }
// et setera



// проверка положения
if(hero->x < 0) { hero->x = map_width -1; }
// etc

/* update state */

if(o->delay > 0) {
  o->delay--;
}

if((0 == o->delay)&&(1 == o->m)) {

  // запомнить позицию перед перемещением
  o->px = o->x;
  o->py = o->y;

  // определение, в какую сторону перемещаться
  select(o->d) {
    case d_right:
      o->x += 1;
      o->delay = o->vmax - o->v; // current velocity
      break;

    /* et setera */
  }

  // обновление положения хвоста.
  for(int i = 0; i < o->size; i++) {

    o->body[i].px = o->body[i].x;
    o->body[i].py = o->body[i].y;

    if(0 == i) {
      o->body[i].x = o->px;
      o->body[i].y = o->py;
    } else {
      o->body[i].x = o->body[i-1].px;
      o->body[i].y = o->body[i-1].py;
    }
  }
}

/* render */
// не сделать ли общий заголовочный файл
// с описанием свойств мира?
// и не сделать ли часть функций макросами?
// (наверное, нет из-за автопеременных...)
// *4i?.. - фреймовый вариант
renderTexture2i(ren, o->head_tile, o->x * tile_size, o->y * tile_size)
for(int i = 0; i < o->size; i++) {
  renderTexture2i(ren, o->body_tile, o->body[i].x * tile_size,
                  o->body[i].y * tile_size);
}
Версия с кадром!

/* бонус(ы) */
Если бонус 1, то можно держать один постоянный объект
с набором свойств:
* x, y
* blink
* visible (хотя можно вынести на точку -1,-1)
* tile_x, tile_y
* life (таймер существования бонуса, на нуле "перескакивает",
           на новую позицию и заряжает таймер)
* life_max
* type (тип бонуса: рост, уменьшитель,
                    ускоритель, замедлитель,
                    очки, бомба ^_^)
В случае с множеством типов бонусов нужно сделать настройку
вероятности выпадания бонуса (просто псевдослучайные числа
не интересны). Ну и прикольно было бы, что ящик с бонусом вы-
глядел типа так [ ? ]. Но каждое 3-4 мигание показывал иконку,
что же в нем есть.
